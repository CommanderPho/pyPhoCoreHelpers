"""
This type stub file was generated by pyright.
"""

from attrs import define
from contextlib import ContextDecorator
from typing import Callable, Optional, Tuple

@define(slots=False, repr=False)
class CapturedException:
    """ Stores a captured exception in a try/catch block and its related info/context. Can also format its display.

    Usage:
        import sys
        from pyphocorehelpers.exception_helpers import CapturedException

        # ...

        try:
            # *SOMETHING*
        except Exception as e:
            exception_info = sys.exc_info()
            e = CapturedException(e, exception_info)
            print(f'exception occured: {e}')
            if fail_on_exception:
                raise e

    """
    exc: BaseException = ...
    exc_info: Tuple = ...
    captured_result_state: Optional[object] = ...
    def __repr__(self): # -> str:
        ...
    


class ExceptionPrintingContext(ContextDecorator):
    """ A context manager that prints any exceptions that occur in its body, optionally suppressing them by default
    
    

    Related Notebook:
    "2024-03-05 - Exception Handling and Formatting.ipynb"


    Usage:
        from pyphocorehelpers.exception_helpers import ExceptionPrintingContext

        # Example Suppressing Exception:
            with ExceptionPrintingContext():
                1 / 0  # This will raise a ZeroDivisionError, which will be handled within our context manager and suppressed

        >> prints "/tmp/ipykernel_92629/1788234204.py:3: ZeroDivisionError: division by zero"

        # Example Not Suppressing (re-raising) Exception:
            try:
                with ExceptionPrintingContext(suppress=False):
                    1 / 0  # This will raise a ZeroDivisionError, which will be handled within our context manager but re-raised because suppress=False
            except ZeroDivisionError:
                print("ZeroDivisionError caught in the outer try-except block.")

        >> prints "/tmp/ipykernel_92629/1788234204.py:3: ZeroDivisionError: division by zero"
            raise exception, printing "ZeroDivisionError caught in the outer try-except block."


        # Example with custom `exception_print_fn`:
            with ExceptionPrintingContext(suppress=True, exception_print_fn=(lambda formatted_exception_str: print(f'\ta_prefix: {formatted_exception_str}')))::
                1 / 0  # This will raise a ZeroDivisionError, which will be handled within our context manager and suppressed

        >> prints "a_prefix: /tmp/ipykernel_102148/4108766447.py:2: ZeroDivisionError: division by zero"

    Generated by ChatGPT:
        by returning True from the __exit__ method, you are telling Python to suppress the exception once it has been handled. If you want the exception to be propagated (i.e., to be thrown outside of the with block), you can either return False or not return anything explicitly from the __exit__ method. 

    """
    def __init__(self, suppress=..., exception_print_fn: Optional[Callable] = ...) -> None:
        """

        exception_print_fn: accepts a callable that takes a single string, the formatted output or defaults to the print function

        """
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> bool:
        """ 
            The __exit__ method is run when exiting the context.
            It receives the exception type, value, and traceback if an exception has occurred
        """
        ...
    
    def print_formatted_exception(self, exc_type, exc_value, traceback): # -> None:
        ...
    


class StackTraceFormatting:
    """

    https://stackoverflow.com/questions/31949760/how-to-limit-python-traceback-to-specific-files
    vaultah answered Oct 9, 2015 at 15:43

    They both use the traceback.extract_tb.
    It returns "a list of “pre-processed” stack trace entries extracted from the traceback object"; all of them are instances of traceback.FrameSummary (a named tuple).
    Each traceback.FrameSummary object has a filename field which stores the absolute path of the corresponding file.
    We check if it starts with any of the directory paths provided as separate function arguments to determine if we'll need to exclude the entry (or keep it).

    """
    @classmethod
    def spotlight(cls, *show): # -> Callable[..., None]:
        ''' Return a function to be set as new sys.excepthook.
            It will SHOW traceback entries for files from these directories. 
            https://stackoverflow.com/questions/31949760/how-to-limit-python-traceback-to-specific-files
            vaultah answered Oct 9, 2015 at 15:43
        '''
        ...
    
    @classmethod
    def shadow(cls, *hide): # -> Callable[..., None]:
        ''' Return a function to be set as new sys.excepthook.
            It will HIDE traceback entries for files from these directories. 
            https://stackoverflow.com/questions/31949760/how-to-limit-python-traceback-to-specific-files
            vaultah answered Oct 9, 2015 at 15:43
        '''
        ...
    
    @classmethod
    def restore_default(cls): # -> Callable[[type[BaseException], BaseException, TracebackType | None], None]:
        """ Restores the default sys.excepthook from sys.__excepthook__
        
        """
        ...
    
    @classmethod
    def shadow_sitepackages(cls): # -> Callable[..., None]:
        ...
    


