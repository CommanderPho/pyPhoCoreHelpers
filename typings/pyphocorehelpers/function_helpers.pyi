"""
This type stub file was generated by pyright.
"""

from typing import Callable, Optional

def compose_functions(*args, progress_logger=..., error_logger=...): # -> Callable[..., Any]:
    """ Composes n functions passed as input arguments into a single lambda function efficienctly.
    right-to-left ordering (default): compose(f1, f2, ..., fn) == lambda x: f1(...(f2(fn(x))...)
    # OLD: left-to-right ordering: compose(f1, f2, ..., fn) == lambda x: fn(...(f2(f1(x))...)
    Note that functions are composed from right-to-left, meaning that the first function input is the outermost function
    Usage:
        post_load_functions = [lambda a_loaded_sess: estimation_session_laps(a_loaded_sess), lambda a_loaded_sess: a_loaded_sess.filtered_by_neuron_type('pyramidal')]
    composed_post_load_function = compose_functions(*post_load_functions) # functions are composed right-to-left (math order)
    composed_post_load_function(curr_kdiba_pipeline.sess)
    """
    ...

def compose_functions_with_error_handling(*args, progress_logger=..., error_logger=...): # -> Callable[..., tuple[Any, dict[Any, Any]]]:
    """ Composes n functions passed as input arguments into a single lambda function efficienctly.
    right-to-left ordering (default): compose(f1, f2, ..., fn) == lambda x: f1(...(f2(fn(x))...)
    # OLD: left-to-right ordering: compose(f1, f2, ..., fn) == lambda x: fn(...(f2(f1(x))...)
    Note that functions are composed from right-to-left, meaning that the first function input is the outermost function
    Usage:
        post_load_functions = [lambda a_loaded_sess: estimation_session_laps(a_loaded_sess), lambda a_loaded_sess: a_loaded_sess.filtered_by_neuron_type('pyramidal')]
        composed_post_load_function = compose_functions(*post_load_functions) # functions are composed right-to-left (math order)
        composed_post_load_function(curr_kdiba_pipeline.sess)
    """
    ...

def add_method(cls): # -> Callable[..., Any]:
    """Enables post-hoc method adding to any python class using a simple decorator design. Enables easily "extending" classes at runtime or in jupyter notebooks without magic.
        From https://gist.github.com/mgarod/09aa9c3d8a52a980bd4d738e52e5b97a
        Credit to mgarod
        From article https://mgarod.medium.com/dynamically-add-a-method-to-a-class-in-python-c49204b85bd6
        
    Usage: Example of adding two functions to a class named "cls_A"
        # Non-decorator way (note the function must accept self)
        # def foo(self):
        #     print('hello world!')
        # setattr(cls_A, 'foo', foo)

        # def bar(self, s):
        #     print(f'Message: {s}')
        # setattr(cls_A, 'bar', bar)

        # Decorator can be written to take normal functions and make them methods
        @add_method(cls_A)
        def foo():
            print('hello world!')

        @add_method(cls_A)
        def bar(s):
            print(f'Message: {s}')



    """
    ...

_custom_function_metadata_attribute_names = ...
def global_function(is_global: bool = ...): # -> Callable[..., Any]:
    """Adds function attributes to a function that marks it as global

    ```python
        from pyphocorehelpers.function_helpers import global_function

        @global_function()
        def _perform_time_dependent_pf_sequential_surprise_computation(computation_result, debug_print=False):
            # function body
    ```

    func.is_global
    """
    ...

def function_attributes(short_name=..., tags=..., creation_date=..., input_requires=..., output_provides=..., uses=..., used_by=..., related_items=..., conforms_to=..., is_global: bool = ..., validate_computation_test: Optional[Callable] = ..., requires_global_keys=..., provides_global_keys=...): # -> Callable[..., Any]:
    """Adds function attributes to a function or class

    ```python
        from pyphocorehelpers.function_helpers import function_attributes

        @function_attributes(short_name='pf_dt_sequential_surprise', tags=['tag1','tag2'], input_requires=[], output_provides=[], uses=[], used_by=[], related_items=[])
        def _perform_time_dependent_pf_sequential_surprise_computation(computation_result, debug_print=False):
            # function body
            
        
    ```

    func.short_name, func.tags, func.creation_date, func.input_requires, func.output_provides, func.uses, func.used_by, func.related_items, func.conforms_to, func.is_global, func.validate_computation_test
    """
    ...

def invocation_log(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], None]:
    """Logs before and after calling a function
    https://towardsdatascience.com/why-you-should-wrap-decorators-in-python-5ac3676835f9
    Args:
        func (_type_): _description_

    Returns:
        _type_: _description_

    Usage:

    @invocation_log
    def say_hello(name):
        '''Say hello to someone'''
        print(f"Hello, {name}!")

    """
    ...

