"""
This type stub file was generated by pyright.
"""

from attrs import define
from neuropy.utils.mixins.indexing_helpers import UnpackableMixin

def centeroidnp(arr): # -> tuple[Any, Any]:
    """ Calculate the centroid of an array of points
        History: refactored from `pyphoplacecellanalysis.PhoPositionalData.analysis.helpers`
    """
    ...

def min_max_bounds(arr): # -> list[Any]:
    """ Calculate the min and max of an array of points
        History: refactored from `pyphoplacecellanalysis.PhoPositionalData.analysis.helpers`
    """
    ...

def bounds_midpoint(arr): # -> list[Any]:
    """ calculates the (x, y) midpoint given input in the format [min_x, max_x, min_y, max_y]
        History: refactored from `pyphoplacecellanalysis.PhoPositionalData.analysis.helpers`
    """
    ...

def point_tuple_mid_point(*args):
    """ returns the center of either a two-element (min, max) tuple or two explicit min, max arguments
    Usage:
        from pyphocorehelpers.geometry_helpers import point_tuple_mid_point
        grid_bin_bounds_center_point = (point_tuple_mid_point(grid_bin_bounds[0]), point_tuple_mid_point(grid_bin_bounds[1]))
        grid_bin_bounds_center_point
    """
    ...

def is_point_in_rect(test_point, rect) -> bool:
    """ Tests if test_point is within or on the boundary of `rect`
        test_point is (x, y) with y being optional.
        rect is specified as (rx, ry, rw, rh, *optional_ignored_extras)

    Usage:
        from pyphocorehelpers.geometry_helpers import is_point_in_rect
    """
    ...

def min_max_1d(data): # -> tuple[Any, Any]:
    ...

def compute_data_extent(xpoints, *other_1d_series): # -> NDArray[float64]:
    """Computes the outer bounds, or "extent" of one or more 1D data series.

    Args:
        xpoints ([type]): [description]
        other_1d_series: any number of other 1d data series

    Returns:
        xmin, xmax, ymin, ymax, imin, imax, ...: a flat list of paired min, max values for each data series provided.
        
    Usage:
        # arbitrary number of data sequences:        
        xmin, xmax, ymin, ymax, x_center_min, x_center_max, y_center_min, y_center_max = compute_data_extent(active_epoch_placefields2D.ratemap.xbin, active_epoch_placefields2D.ratemap.ybin, active_epoch_placefields2D.ratemap.xbin_centers, active_epoch_placefields2D.ratemap.ybin_centers)
        print(xmin, xmax, ymin, ymax, x_center_min, x_center_max, y_center_min, y_center_max)

        # simple 2D extent:
        extent = compute_data_extent(active_epoch_placefields2D.ratemap.xbin, active_epoch_placefields2D.ratemap.ybin)
        print(extent)
    """
    ...

def corner_points_from_extents(extents, debug_print=...): # -> NDArray[Any]:
    """  Gets the corner points of the bounding shape specified by extents.
    Usage:
        xmin=23.923329354140844, xmax=263.92332935414083, ymin=123.85967782096927, ymax=153.85967782096927
        points = corner_points_from_extents([xmin, xmax, ymin, ymax])
        extent_pairs_list: [[23.923329354140844, 263.92332935414083], [123.85967782096927, 153.85967782096927]]

        points: array([[ 23.92332935, 123.85967782],
               [ 23.92332935, 153.85967782],
               [263.92332935, 123.85967782],
               [263.92332935, 153.85967782]])

    Example 2:
        points = corner_points_from_extents([23, 260, 124, 154])
            extent_pairs_list: [[23, 260], [124, 154]]
            points: [[ 23 124]
             [ 23 154]
             [260 124]
             [260 154]]

    Example 3:
        points = corner_points_from_extents([23, 260, 124, 154, 0, 1])
            extent_pairs_list: [[23, 260], [124, 154], [0, 1]]
            points: [[ 23 124   0]
             [ 23 124   1]
             [ 23 154   0]
             [ 23 154   1]
             [260 124   0]
             [260 124   1]
             [260 154   0]
             [260 154   1]]
    """
    ...

def compute_data_aspect_ratio(xbin, ybin, sorted_inputs=...): # -> tuple[Any, Width_Height_Tuple]:
    """Computes the aspect ratio of the provided data

    Args:
        xbin ([type]): [description]
        ybin ([type]): [description]
        sorted_inputs (bool, optional): whether the input arrays are pre-sorted in ascending order or not. Defaults to True.

    Returns:
        float: The aspect ratio of the data such that multiplying any height by the returned float would result in a width in the same aspect ratio as the data.
    """
    ...

@define(slots=False)
class BoundsRect(UnpackableMixin):
    """ Kinda overkill. Represents a boundary rectangle.
    
    from pyphocorehelpers.geometry_helpers import BoundsRect
    
    grid_bin_bounds = BoundsRect.init_from_grid_bin_bounds(global_pf2D.config.grid_bin_bounds)
    grid_bin_bounds

    """
    xmin: float = ...
    xmax: float = ...
    ymin: float = ...
    ymax: float = ...
    @property
    def size(self): # -> tuple[float, float]:
        ...
    
    @property
    def extents(self): # -> list[float]:
        ...
    
    @property
    def range_pairs(self): # -> tuple[tuple[float, float], tuple[float, float]]:
        """ ((x, x2), (y, y2)) = grid_bin_bounds """
        ...
    
    @property
    def corner_points(self): # -> NDArray[Any]:
        ...
    
    @property
    def relative_midpoint(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def center_point(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def aspect_ratio(self) -> float:
        ...
    
    @classmethod
    def init_from_grid_bin_bounds(cls, grid_bin_bounds): # -> Self:
        ...
    
    @classmethod
    def init_from_x_y_w_h_tuple(cls, x_y_w_h_tuple): # -> Self:
        ...
    
    def __iter__(self): # -> Generator[tuple[float, float], Any, None]:
        """ allows unpacking """
        ...
    
    def contains_point(self, test_point) -> bool:
        ...
    


def find_ranges_in_window(epoch_starts, epoch_ends, active_window): # -> tuple[Any, NDArray[intp], Any, Any, Any]:
    """ finds the epochs that lie either wholly or partially within the active_Window.
    This can be used for example to find the epochs that fall within the visualization window to know which rectangles to draw.
    
    Inputs:
        epoch_starts: an array of size {N,}
        epoch_ends: an array of size {N,}
        active_window: a tuple or list containing 2 elements representing the (win_start, win_end) times of the current window
        
    Returns:
        is_range_in_window: a boolean array of size {N,} that indicates whether the epoch is (either partially or fully) within the active window.
        included_epoch_indicies: an array of size {F,} containing the index of the original input epochs
        included_epoch_starts: an array of size {F,} containing the (potentially modified if truncated) start times for each epoch in the window
        included_epoch_ends: an array of size {F,} containing the (potentially modified if truncated) stop times for each epoch in the window
        included_epoch_is_truncated: an array of size {F,} containing a boolean value indicating whether that epoch was truncated by the edges of the window

    Usage:
        is_range_in_window, included_epoch_indicies, included_epoch_starts, included_epoch_ends, included_epoch_is_truncated = find_ranges_in_window(curr_sess.pbe.starts, curr_sess.pbe.stops, (598.65, 820.0))
        print(f'included_epoch_indicies: {np.shape(included_epoch_indicies)}')
        print(f'included_epoch_starts: {np.shape(included_epoch_starts)}')
        # build a dataframe to preview output
        pd.DataFrame({'included_epoch_indicies':included_epoch_indicies, 'included_epoch_starts':included_epoch_starts, 'included_epoch_ends':included_epoch_ends, 'included_epoch_is_truncated': included_epoch_is_truncated})
    
    
    """
    ...

def map_value(value, from_range: tuple[float, float], to_range: tuple[float, float]):
    """ Maps values from a range `from_low_high_tuple`: (a, b) to a new range `to_low_high_tuple`: (A, B). Similar to arduino's `map(value, fromLow, fromHigh, toLow, toHigh)` function
    
    Usage:
        from pyphocorehelpers.geometry_helpers import map_value
        track_change_mapped_idx = map_value(track_change_time, (Flat_epoch_time_bins_mean[0], Flat_epoch_time_bins_mean[-1]), (0, (num_epochs-1)))
        track_change_mapped_idx
        
    Example 2: Defining Shortcut mapping
        map_value_time_to_epoch_idx_space = lambda v: map_value(v, (Flat_epoch_time_bins_mean[0], Flat_epoch_time_bins_mean[-1]), (0, (num_epochs-1))) # same map

    """
    ...

